{"pages":[],"posts":[{"title":"00_laser scan SLAM","text":"잡담수중에서는 3차원 측정을 위한 센서가 매우 부족하다. 스테레오 비전을 쓰기도 하지만, 워낙 피쳐가 부족한 환경이라서 잘 되는지는 의문 Lidar 같은 장비나 리얼센스 같은 장비가 수중용이 없다.. 돈이 안되서 그런가 보통 이러한 장비들은 육상용의 경우 사람 눈에 영향을 줄 수 있어서 매우 제한적인 파워로 극도의 성능을 뽑아낸다. 수중에는 사람도 없으니까 파워 왕창 높히면 장비 사용할 수 있을텐데.. 아쉽 수중생물에 영향을 줄 수 있어 환경단체의 반대를 받을 수 있다. 조심 Line Laser scan수중에서는 고전적일 수 있는 찐 레이저를 쓴다. 왜 찐 레이저라고 했냐면, 눈에 보이는 레이저이기 때문. 보통 육상에서 쓰는 대부분의 레이저 장비들은 가시광선이 아니라서 눈에 보이지 않는다. 하지만 수중에서는 그런거 없고 파워풀하게 녹색이나 파란색 레이저를 쓴다. 빨간 레이저는 쓰지 않는다. 빨간색은 수중에서 감쇄가 심하기 때문이다. 그리고 수중 카메라로 색상 인식을 해서 그 laser 부분의 3차원 위치정보를 얻는다. 매우 고전적이지만 확실한 방법이다. (수중에서 Structured Light를 이용해서 한번에 depth를 얻는 장비도 구현되어 있더라. 없으니까 패스) 나는 이러한 laser scan 방법론을 활용하여 수중에서 간단하게 SLAM을 구현해보고자 한다. 고찰SLAM은 흔히 camera 기반 슬램이 있고 라이다나 뎁스 센서로 이루어지는 SLAM이 있고, 방식 등으로는 여러가지가 있지만 Graph based SLAM 방식을 많이들 쓴다 Pose Graph SLAM 이라고도 하던데, 간단하게 말하면 시간에 따라서 Robot의 Pose들을 시리얼하게 딱딱 이어 묶고는 그 사이의 Transformation을 각각 계산해둔다. 그러면 일자로 이어진 그래프?가 될 것인데, Loop Closure가 발생하면 이를 보정하기 위해서 각각의 Pose들을 최적화시키게 된다. 이때 Pose는 Position과 Attitude를 포함한 Robot의 정보다. 쉽게말해서 원형으로 로봇이 움직인다고 했을 때 출발한 지점으로 Robot이 돌아오게 되면, 출발지의 Pose와 지금껏 Robot이 추정하여 현재 있을 것이라고 예측했던 위치가 알맞지 않을 것이다 (오차가 계속해서 누적되었기 때문). 이를 바로잡아 주는 과정이 Loop Closure이다. SLAM 영상들을 보면 지도가 만들어지다가 갑자기 뚝뚝 일부의 지도들이 갑작스럽게 어디론가 딱 붙는다던지 하는 모습을 보여주는데, 그게 Loop Closure이다. Loop Closure과정을 보면 일부의 생선된 지도들이 딱딱 알맞게 붙어들어가게 되는데, 이는 생각보다 간단한 과정으로 해결가능하다 (물론 그 과정 자체의 계산은 매우 복잡하지만). Solver를 사용하면 이를 풀어낼 수 있다. Solver가 무었이냐 하면 쉽게말하면 연립방정식을 풀어주는 것이다. (학부시절에 쓰던 CASIO 공학계산기에도 Solver기능이 있어서 매우 편하게 문제를 풀 수 있었다. 그때 생각해보면 해의 범위를 설정해줘야 해서 이게 왜 필요한가 생각했었는데, Solver의 의미를 알고나니 이해가 된다.) 여튼 Solver가 Loop Closure에서 작동하는 원리는 간단하다. 우선 Robot의 Pose들이 이어져 있을때, 그 Pose 사이에는 Transform Matrix가 존재한다. 3차원 이동과 회전이 동시에 이루어지는 그 행렬이다. 이를 Edge라고 표현하더라 여튼 Loop Closure가 시작된 Pose에서 현재의 Pose사이에는 여러차례 알맞은 Edge가 곱해져서 표현이 된다. Edge로써 현재의 Pose가 추정된 것이다. 이 모든 Edge에 어떠한 미지수를 각각 곱했을 때 현재의 Pose가 시작된 Pose에 가장 가까워질 수 있도록 (거의 일치하도록) 하고 Solver를 활용하여 그 미지수를 구하는 것이다. 그 미지수를 구하게되면, 실제 그 미지수를 각 Edge에 곱해서 Pose들을 다시 Update하면 지도가 찰싹 붙는 것을 보여줄 수 있는 것이다. 그래서 이러한 Loop Closure 과정은 일반적으로 컴퓨팅 양이 많기때문에 SLAM 알고리즘에서 Backend 과정으로 분류한다. 가끔 일어나지만 시간을 오래걸리니 조금 뒷단에서 처리하겠다는 느낌 자연스럽게 Frontend는 실시간으로 현재의 Pose를 추정하여 Node를 구성하는 것이다 (말은 안했지만 Node가 Graph에서 현재의 Pose들을 나타내는 용어임 Graph는 Node와 Edge로 구성되어 있다.) 자 위 과정을 이해했다면 Pose Graph SLAM을 이해한 것이다. 물론.. 나도 잘 이해한 건지는 모르겠다.","link":"/2022/04/06/00-laser-scan-slam/"},{"title":"github 관리를 한번 해봐야겠다","text":"잡담Github 관리를 해봐야겠다. 하드디스크 털어서 Mbed나 PCB디자인이나 ROS나 OPEN CV나 등등 모든 템플릿들을 정리해서 올려둬야 겠다. 그러면 내가 또 들고와서 잘 쓸 수 있게끔. 근데 대부분이 다 나도 퍼오고 조금씩 수정해서 쓰는 것들인데, 그럼 다른 github들이랑은 어떻게 연결해야할지.. 감이 잘 안잡히지만 그래도 어떻게든 해봐야지 잘 꾸며봐야겠다. 근데 이 블로그도 github 에 commit 기록에 들어가는 것 같은데, 블로그 자주 쓴다고 github가 초록밭이 되면 조금 허위 가짜 github가 되는 느낌이다. 블로그 deploy는 조금 자제해야겠다. 글 완성하고 올리는 형태를 지향","link":"/2022/04/07/00-ros-mbed-arduino-github/"},{"title":"01_laser scan SLAM","text":"잡담내가 가진 상황에 맞게 수중로봇에서 Pose Graph SLAM를 빠르게 구현해서 실험까지 해내야 한다. 시뮬레이터도 있고 수조실험 일정도 잡혔다. 그 전에 해야할 일의 목록을 정리해보면 시뮬레이션에서 목표한 움직임대로 수행하여 rosbag 제작 rosbag에 대하여 pose graph slam을 활용한 자체 알고리즘 제작/테스트 작은 수조에서 bricks들에 대한 dataset 제작, YOLOv4 학습, Laser Scan test 수조 실험 수행 (4월 18일 주) 논문 초안 작성 (4월 중) 논문 투고 (5월 초) 지금까지 되어있는 부분 목록 논문 제목 Underwater Recursive Rotational SLAM 이라고 URR-SLAM으로 이름 지음. 시작이 반이다. 로봇 시뮬레이터. 매번 고맙게 활용하는 UUV Sim.. 내 로봇을 기반으로 이식해두어서 언제든지 간이 실험을 수행해볼 수 있음 시뮬레이터 맵 생성. 아래와 같은 전략이다. 벽돌 모형도 실제 크기와 같이 구현해두고, 4가지 부분을 사각형으로 이동해서 Loop Closure를 보여줄 듯 Bricks들 YOLOv4 학습. 4가지 종류의 Bricks를 4가지 구분해서 125장 정도씩 data set 구성하고 일반 YOLOv4에 학습했다. 실제 로봇에서는 Tiny 모델로 써야함. Laser Scan Sensor를 Gazebo에서 구현된 값 그대로 활용하지 않고, 로봇 앞부분의 Camera로 Image 읽고 다시 3차원 laser scan으로 계산하도록 Vision 처리하는 코드 작성. 실제 로봇에서 해당 node Package를 사용해야 하기 떄문에 구조상 미리 작성 뭔가 많이 한 것 같지만 개뿔 pose graph slam 구현하는 부분이 제일 중요하고 어렵다. 다른건 그냥 시간만 있으면 되는데 이 부분은 머리싸매고 차근차근 빠르게 해내야 한다. 우선 SLAM의 Backend 부분은 어찌저찌 ceres solver 활용하면 가능할 것 같아서 감이 슬쩍 잡히는데 Frontend 부분은 map 구성도 그렇고, Line Laser Matching도 그렇고 해야할 부분이 많다. 할게 많을때는 할 수 있는 것부터 하라고 했다. 그래서 rosbag부터 만들고, 그걸로 반복반복 할 수 있도록 해야겠다. 고찰아쉽게도.. 이번달에 완성해서 투고까지가 목표이므로, 투고 이후에 Laser Scan SLAM 부분을 다시 작성해야 겠다.","link":"/2022/04/07/20220407_01-laser-scan-slam/"},{"title":"깃허브에 이전에 작성된 코드를 올리는 방법","text":"잡담기존에 작업한 애들을 github에 잘 정리하면서 올리는 순서에 대한 기록 사실 나는 다수와 함께 코딩을 해본적은 없어서, 크게 github에서 다양한 기능을 사용하지는 않을 듯 하다. 그냥 commit만 주구장창 하는 정도일려나 미래에 회사에 가게 된다면 필수적으로 체득하게 되지 않을까 싶다. 이제 코딩할때는 github를 계속 사용하는 습관을 들여봐야겠다. 예전에는 README 완전 대충 쓰곤 했는데, 블로그를 쓰다보니 이게 markdown이라는 것을 알게 되었고 문법도 엄청 쉽고 익숙해지는 듯 방법 Github에서 new repository 만들기 (README .gitignore License 를 추가, .gitignore는 안해도됨, License는 시원하게 오픈해야 하니까 MIT) Ubuntu terminal에서 새로 올리고자 하는 source 폴더로 이동 git 초기화하기1git init 원격저장소 github로 지정하기, 위에서 만든 github의 repo 주소를 사용1git remote add origin https://github.com/robotjuhwan/ros_arduino_agent_vehicle.git github 기본 내용을 가져오기 (새로 생성된 README .gitignore License를 가져온다고 생각하면 됨)1git pull origin main git branch인 master를 main으로 변경 (github의 기본 branch는 main인데 init에서 만들어주는 branch는 default가 master임. main으로 바뀐지는 얼마 안되었다고 함)놀랍게도 whitelist/blacklist master/slave 라는 어떠한 인종차별적(?) 주종관계(?) 등으로 PCPC 적인 부분 떄문에 main으로 바뀌었다고 한다..git version 2.18 이상부터는 기본적으로 init을 하면 main으로 생성됨.. 근데 나는 2.17버전이네. 그러면 기본 branch가 master로 생성되기 때문에 이를 지우고 main으로 바꿔줘야 한다..그런데 지우는걸 먼저하는것이 아닌, main을 생성하고 이것으로 바꿔주고나서 master를 지울 수 있음. 업데이트 그냥 하는게 나을 듯123git branch maingit checkout maingit branch -d master 소스의 기존 파일들을 새롭게 추가. 아래 명령으로 손쉽게 추가된다. .gitignore에 따라서 자동으로 제외되지 않는 파일/폴더가 딱딱 추가됨1git add . commit하기. 변경된 파일들에 대해서 commit 한다.1git commit -m &quot;init&quot; push하기. push 해서 github에 실제로 딱 보낸다.1git push origin main github 저장소로 가서 올라간 소스들을 본다.흐뭇~ 추가우분투 Ubuntu에서 git upgrade 하기 ubuntu에서 git을 업그레이드하려고 그냥 sudo apt install로 해보니까 2.17이 최신버전이라고 뜬다.아래와 같이 써보면 현재 git version이 나온다 1git version 아래와 같이 apt에 repo를 추가하고 update하면 apt install을 통해 git 업그레이드가 가능하다 123sudo add-apt-repository ppa:git-core/ppa -ysudo apt updatesudo apt install git -y 이후 버전을 확인해보니 아래와 같이 2.35.1 버전으로 확인되었다. 1git version 2.35.1","link":"/2022/04/07/20220407_github-upload/"},{"title":"블로그를 시작하는 첫 글","text":"첫 글블로그를 시작합니다. 아직은 어떻게 하는지 잘 모르겠지만 과거에 워드프레스로 직접 서버를 구동하는 형식보다 깃허브로 블로그를 운영하면 기술 블로그로 활용이 가능할 것 같다는 생각을 했습니다. 1코딩도 잘 표현할 수 있고 좋은 듯 MarkDown 문법도 숙지해야 겠다. 이 문법은 md 파일의 문법, 여튼 여기 게시판을 쓰기위한 문법이다 음식이랑 여행도 많이많이 기록해야지 중요이곳에 기술된 내용은 대부분 맞겠지만 틀린 내용을 당연히 서술할 가능성이 높습니다. 이 곳의 내용은 절대 Reference로 활용될 수 없을 것입니다.. 틀린 내용이나 지식이 있다면 단연코 댓글로 알려주시면 수정하도록 하겠습니다.","link":"/2022/04/06/first-post/"},{"title":"ros_ceres_pcl 패키지","text":"잡담ROS1만 주구장창 하는게 맞나싶긴 하지만 일단 빨리빨리 할수있는걸 하는게 맞는 듯. ROS2도 빨리 플젝하나 해버려야하는데.. SLAM에서 중요한 부분이 PCL 라이브러리를 추가해서 포인트클라우드를 조금 만지작 거려야 하고 ceres solver 활용해서 loop closure를 구현해야 한다. 그러니 이 두개를 ROS에서 사용해야 한다. 깃허브 올리기깃허브에 기존 패키지 올리기를 통해서 이번 패키지도 추가해서 한번 올려보았다. 깃허브에 이전에 작성된 코드를 올리는 방법 이번 패키지는 아래 블로그를 참조하여 작성하였다. 매우 감사한 블로그. 다 정독할 듯 Hyungtae Lim 여튼 아래와 같이 crese solver와 pcl 라이브러리 추가해서 ros에서 빨리 간단한 SLAM을 구현해봐야함.. 할일이 많다. ros_ceres_pcl_template","link":"/2022/04/11/ros-ceres-pcl/"},{"title":"move_lab","text":"잡담연구실 이사를 했는데 실험실 구역에서 제대로된 오피스구역으로 이동했다. 햇빛도 들고 더 좋아진 듯 서버를 켜질 못해서 포스팅이 더뎠다. 그 사이 adsense도 신청해보고 맛집블로그도 다시 차근차근 써봐야겠다. 옛날에는 잔뜩 썼었는데 요긴하게 쓰였다. 거진 한달간 글을 못썻는데 다시 많이 써야겠음.","link":"/2022/05/02/20220502_move-lab/"}],"tags":[{"name":"SLAM","slug":"SLAM","link":"/tags/SLAM/"},{"name":"Underwater","slug":"Underwater","link":"/tags/Underwater/"},{"name":"Github","slug":"Github","link":"/tags/Github/"},{"name":"Mbed","slug":"Mbed","link":"/tags/Mbed/"},{"name":"ROS","slug":"ROS","link":"/tags/ROS/"},{"name":"Chat","slug":"Chat","link":"/tags/Chat/"}],"categories":[{"name":"Study","slug":"Study","link":"/categories/Study/"},{"name":"Github","slug":"Study/Github","link":"/categories/Study/Github/"},{"name":"SLAM","slug":"Study/SLAM","link":"/categories/Study/SLAM/"},{"name":"Chat","slug":"Chat","link":"/categories/Chat/"}]}